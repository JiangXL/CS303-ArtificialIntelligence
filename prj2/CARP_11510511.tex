\documentclass[conference,compsoc]{IEEEtran}

% *** CITATION PACKAGES ***
%
\ifCLASSOPTIONcompsoc
  % IEEE Computer Society needs nocompress option
  % requires cite.sty v4.0 or later (November 2003)
  \usepackage[nocompress]{cite}
\else
  % normal IEEE
  \usepackage{cite}
\fi


\usepackage{amsmath}
\usepackage{algorithm, algorithmic}
\renewcommand{\algorithmicrequire}{\textbf{Input:}}
\renewcommand{\algorithmicensure}{\textbf{Output:}}
\usepackage{array}
\usepackage{url}
% correct bad hyphenation here
\hyphenation{op-tical net-works semi-conduc-tor}


\begin{document}
\title{Project 2: Capacitated Arc Routing Problems }

% author names and affiliations
% use a multiple column layout for up to three different
% affiliations
\author{\IEEEauthorblockN{Yuejian Mo  11510511}
\IEEEauthorblockA{Department of Biology\\
Southern University of Science and Technology\\
Email: 11510511@mail.sustc.edu.cn}}

% make the title area
\maketitle

\IEEEpeerreviewmaketitle

\section{Preliminaries}
This project is an implementations of Path-Scanning and Dijkstra's algorithm to
solve the capacitated arc routing problems(CARP). 

This project is doing some simple implementations on Gomoku. Gomoku, also called 
Five in a Row, is an abstract strategy board game. It is traditionally played 
with Go pieces (black and white stones) on a Go board, using 15x15 of the 19x19
grid intersection.\cite{1} Gomoku has less complicity than Go, which has encouraged
Deep Mind to develop powerful AI engine AlphaGo in 2016. So Gomoku will be a
better particle for beginner. Design of Gomoku AI in this project try to
follow the minMax tree with alpha-beta punching, which powered AI Deep Blue to
challenge top chess player successfully in the first time.

\subsection{Software}
This project is written by Python 3.7 with editor Atom and Vim. Numpy library
and sys library are used.

\subsection{Algorithm}
Using Dijkstra's algorithm to calculate the closest pathway between two vertex.
Path-Scanning is used to find out task sequence for CARP. I defined three group
of functions in order to find out optimal service sequence, including one
function to generate cost graph and demand graph between vertex and vertex
from provided txt file, two functions to generate shortest distance and pathway
dictionary by Dijkstra algorithm, other are control flow and output format
function.


\section{Methodology}
CARP is NP-hard problem.

Different chess layout present different chance to win. For example, live-four
and double-three must lead to success. So I evaluate the score of possible
layout in final level of DFS. For every layout, I scan each line in vertical,
horizontal and diagonal to calculate score and sum three together valued as
whole chess layout score. Then, all score were judged by minMax tree to found
out best choose position. To speed up minMax tree, alpha-beta punching was used
to reduce the number of node to expand.

\subsection{Representation}
Some main data are maintain during process: \textbf{capacity},\textbf{graph\_dm}
, \textbf{graph\_ct}.
Others data would be specified inside functions, shortest\_dist should noticed.

\begin{itemize}
  \item \textbf{capacity}: The car's capacity, generated from input file.
  \item \textbf{graph\_dm}: The graph of edge with demand and their demand,
  generated from input file.
  \item \textbf{graph\_ct}: The graph of edge with cost and their cost,
  generated from input file.
  \item \textbf{shortest\_dist}: A dictionary of shortest distance and pathway
  between two vertexes. 
\end{itemize}


\subsection{Architecture}
Here list all functions in given code:
\begin{itemize}
    \item \textbf{generateGraph}: Generate cost and demand graph from input file.
    \item \textbf{dijkstra}: Calculate all vertexes closest distance and
    pathway away from specify source.
    \item \textbf{genDijkstraDist}: Generate each two vertexes closest distance
    and pathway from \textbf{dijkstra} function.
    \item \textbf{better}: Second rule to choose one vertexes from two vertex. 
    \item \textbf{pathScan}: Path-Scanning algorithm to generate serve sequence. 
    \item \textbf{s\_format}: Standard output function. 
    \item \textbf{\_\_name\_\_}: Main control function. 
\end{itemize}
The CARP\_solver would be executed in test platform.


\subsection{Detail of Algorithm}
Here describes some vital functions.
\begin{itemize}
    \item \textbf{generateGraph}: Generate global cost and demand graph from
    input file.
    \begin{algorithm}[H]
     \caption{generateGraph}
     \begin{algorithmic}[1]
     \renewcommand{\algorithmicrequire}{\textbf{Input:}}
     \renewcommand{\algorithmicensure}{\textbf{Output:}}
     \REQUIRE $input\_file\_name$
     \ENSURE $ $
     \STATE open $input\_file\_name$ as $file$ \COMMENT{open file and read line
     by line}
     \STATE $capacity \leftarrow $file$.readline$
     \STATE \COMMENT{Read each line information until arrive edge information}
     \FOR {each edge $e$}
       \STATE split each line string into an array $line$ with 4 elements.
       \IF{ ($line[3]$ larger than 0)} 
          \STATE $graph\_dm$[($line$[0], $line$[1])]= $line$[3]
          \STATE $graph\_dm[(line[1], line[0])]= line[3]$
          \COMMENT {Only add edge to dictionary $graph\_dm$when edge has
          demand. Both of two direction will be created.}
       \ENDIF
       \STATE $graph\_ct[(line[0], line[1])]= line[2]$
       \STATE $graph\_ct[(line[1], line[0])]= line[2]$
     \ENDFOR
     \end{algorithmic}
   \end{algorithm}

   \item \textbf{dijkstra}: generate closest distance and pathway away from source
     \begin{algorithm}[H]
     \caption{dijkstra}
     \begin{algorithmic}[2]
     \renewcommand{\algorithmicrequire}{\textbf{Input:}}
     \renewcommand{\algorithmicensure}{\textbf{Output:}}
     \REQUIRE $source$
     \ENSURE  $dist$, $prev$
     \STATE create vertex set $Q$
     \STATE create distance set $dist$
     \STATE create path set $prev$
     \FOR { each vertex $v$ in $graph\_ct$ }
        \STATE $dist[v] \leftarrow INFINITY$
        \STATE $prev[v] \leftarrow UNDEFINED$
        \STATE add $v$ to $Q$
     \ENDFOR
     \STATE $dist[source] \leftarrow$ 0
     \WHILE{($Q$ is not empty)}
        \STATE $u$ $\leftarrow$ vertex in $Q$ with min $dist[u]$
        \STATE remove $u$ from $Q$
        \FOR {for each neighbor $v$ in $u$}
           \STATE $alt \leftarrow dist[u] + graph\_ct(u,v)$
           \IF {alt larger than $dist[u]$}
              \STATE $dist[v] \leftarrow alt$
              \STATE $prev[v] \leftarrow u$
           \ENDIF
        \ENDFOR
     \ENDWHILE
     \RETURN $dist$, $prev$
     \end{algorithmic}
     \end{algorithm}

  \item \textbf{genDijstraDist}: generate closest distance and pathway between
  two vertex into a dictionary $shortestDist$
    \begin{algorithm}[H]
     \caption{genDijstraDist}
     \begin{algorithmic}[3]
     \renewcommand{\algorithmicrequire}{\textbf{Input:}}
     \renewcommand{\algorithmicensure}{\textbf{Output:}}
     \REQUIRE $ $
     \ENSURE  $shortestDist$
     \STATE create dictionary $shortestDist$
     \FOR {each edge's first vertex in $graph\_dm$ as $source$ }
       \STATE $dist$, $prev$ $\leftarrow$ dijkstra($source$) 
       \FOR {each edge's first vertex in $graph\_dm$ as $target$ }
         \STATE $shortestDist[source, target] \leftarrow dist$
       \ENDFOR
     \ENDFOR
     \RETURN $shortestDist$
     \end{algorithmic}
     \end{algorithm}
 
   \item \textbf{better}: choose better in pointers 
     \begin{algorithm}[H]
     \caption{better}
     \begin{algorithmic}[4]
     \renewcommand{\algorithmicrequire}{\textbf{Input:}}
     \renewcommand{\algorithmicensure}{\textbf{Output:}}
     \REQUIRE $now$, $pre$
     \ENSURE  $Ture$ or $False$
     \RETURN $graph\_dm[now] < graph\_dm[pre]$
     \end{algorithmic}
     \end{algorithm}
 
   \item \textbf{pathScan}: Path Scanning algorithm to determine serve routes
     \begin{algorithm}[H]
     \caption{pathScan}
     \begin{algorithmic}[4]
     \renewcommand{\algorithmicrequire}{\textbf{Input:}}
     \renewcommand{\algorithmicensure}{\textbf{Output:}}
     \REQUIRE $shortest\_dist$
     \ENSURE  $R$, $cost$
     \STATE create successive routes $R$
     \STATE copy required edge from $graph\_dm$ to $free$ 
     \STATE $k, cost \leftarrow 0$
     \WHILE { $free$ is not empty}
       \STATE $k \leftarrow k+1$
       \STATE $cost\_k, load\_k \leftarrow 0 $
       \STATE rest successive routes $R\_k$ each time 
       \STATE serve from origin vertex: $source \leftarrow 1$
       \WHILE { $free$ in not empty}
         \STATE rest shortest distance: $d \leftarrow \infty$ 
         \STATE rest candidate serve edge: $e\_candidate \leftarrow -1$
         \FOR {each edge $e$ in $free$}
            \IF {$load\_k + graph\_dm[e] \le capacity$}
               \STATE $dist\_now \leftarrow shortest\_dist[source, e.start]$
               \IF {$dist\_now \le d$}
                 \STATE $d \leftarrow dist\_now$
                 \STATE $e\_candidate \leftarrow e$
               \ELSIF {$dist\_now = d$ $\cap$ better($e$,$e\_candidate$ )}
                 \STATE $e\_candidate \leftarrow e$
               \ENDIF
            \ENDIF
         \ENDFOR
         \IF {$e = \infty$}
            \STATE BREAK
         \ENDIF
         \STATE add $e\_candidate$ to $R\_k$
         \STATE $load\_k = load\_k + graph\_dm[e\_candidate]$
         \STATE $cost\_k = cost\_k + graph\_ct[e\_candidate]$
         \STATE $i = e\_candidate.end$
         \STATE remove $e\_candidate$ and its opposite edge from free
       \ENDWHILE
       \STATE add back home distance: $cost\_k = cost\_k + shortest\_dist[i,1]$
       \STATE add $R\_k$ to $R$
       \STATE $cost = cost + cost\_k$
     \ENDWHILE
     \RETURN $R$, $cost$
     \end{algorithmic}
     \end{algorithm}

\end{itemize}


\section{Empirical Verification}
Empirical verification is compared with given test\_code.py and public test
platform.

\subsection{Design}
Successfully to evaluate chessboard score currently. When depth is two, program
output current answer within five second. When I try to run in depth of four,
right answer almost take half of hour. In a word, more powerful evalute
function and punching(heuristic function) are required.

\subsection{Data and data structure}
Dict, list
I use test data provided by code\_test.py to test. Numpy matrix are used widely.

\subsection{Performance}
Right output in depth of two and time of five second. It run so slow when
depth is four.

\subsection{Result}
Successfully pass all data set test.

\subsection{Analysis}
The evaluate chessboard layout score cost linear time. minMax tree cost most
time. The deeper, the more time it cost.

\section*{Acknowledgment}
Thanks TA Yao Zhao who explain question and provide general method to solve it.
And I also thanks for Kebing Sun discuss algorithm and point the output
formation error.

\bibliographystyle{IEEEtran}
\begin{thebibliography}{1}
\bibitem{1}
Wikipedia contributors, [Online], Available: https://en.wikipedia.org/wiki/Gomoku,
[Accessed: 31- Oct- 2018].
\end{thebibliography}

% that's all folks
\end{document}


